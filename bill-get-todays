#!/bin/bash

function getVal {
  grep $1 $2 | awk '{print $2}' | tr -d '",'
}

function getVals {
  IFS='
  '
  echo "$(getVal $1 $2)"
}

# Force bill directory to exist.
REPO=$(readlink -f $(dirname $0))
# Today's date in URL-acceptable format
#DATE=$(date +%Y-%m-%d)
# to debug, pick date in the past.
DATE=2023-05-27
BDIR=$REPO/db/bills/$DATE
PKG_DIR=$BDIR/pkgs/
PKG_URL_DIR=$PKG_DIR/urls
DB=$REPO/.db
# Key
if [ ! -e $REPO/.env ]; then
  echo -e "You need to put a .env file into $SRC_DIR first. Populate that file like so:\n\nCONGRESS_KEY=<your API key>\n"
  exit 1
fi
source $REPO/.env
KEY="api_key=$CONGRESS_KEY"

# Create directory structure.
if [ ! -d $PKG_URL_DIR ]; then
  echo "creating pkg url directory"
  mkdir -p $PKG_URL_DIR
fi

BE_QUIET=-s

# Get this congress's first page of 100 bill summaries. (Time format in URL is yyyy-mm-dd'T'HH:mm:ss'Z'.)
todays_bill_activity=$(curl $BE_QUIET -X 'GET' "https://api.govinfo.gov/collections/BILLS/${DATE}T00%3A00%3A00Z?pageSize=100&offsetMark=*&congress=$1&$KEY")

# Store the first page of results in database.
counter=0
echo $todays_bill_activity | jq '.' > ${PKG_URL_DIR}/${counter}-$DATE

# If there are anymore pages beyond the first, retrieve and store them in the databse as well.
nextPage=$(echo "$todays_bill_activity" | jq '.nextPage' | sed 's/"//g')
while [ ! ${nextPage} = null ]; do
  ((counter += 1))
  echo "nextPage = ${nextPage}"
  todays_bill_activity=$(curl $BE_QUIET -X 'GET' "${nextPage}&$KEY")
  echo $todays_bill_activity | jq '.' >> ${PKG_URL_DIR}/${counter}-$DATE
  nextPage=$(echo $todays_bill_activity | jq '.nextPage' | sed 's/"//g')
done

# For all bill activities today...
for f in $(ls ${PKG_URL_DIR}); do
  # Make an array of IDs
  pkgIds=($(getVals packageId "${PKG_URL_DIR}/$f"))
  # Make a corresponding array of URLs
  pkgUrls=($(getVals packageLink "${PKG_URL_DIR}/$f"))
  # Make sure we have the same number of package URLs as we do package IDs. They need to correspond perfectly.
  if [ ${#pkgIds[*]} -ne ${#pkgUrls[*]} ]; then
    echo "There's supposed to be the same number of package IDs as package URLs in $f. Is it corrupted? Exitting..."
    exit
  fi
  # For each ID-URL mapping in the current batch...
  counter=0
  maxCounter=${#pkgIds[*]}
  while [ $counter -lt $maxCounter ]; do
    id=${pkgIds[$counter]}
    pkgUrl=${pkgUrls[$counter]}
    # I append the counter to the package ID *just in case* there's multiple activity on the same document.
    # Don't re-download pre-existing text docs.
    formattedCounter=$(printf '%03d' $counter)
    pkgDoc=$PKG_DIR/$formattedCounter-${pkgIds[$counter]}
    # Only curl the package if we haven't done so for this one yet.
    if [ ! -e $pkgDoc ]; then
      curl $BE_QUIET "${pkgUrl}?$KEY" > $pkgDoc
      txtUrl=$(getVal txtLink $pkgDoc)
      txtDoc=$BDIR/txt-$formattedCounter-$id
      # Don't re-download pre-existing text docs.
      if [ ! -e $txtDoc ]; then
        curl $BE_QUIET $txtUrl?$KEY > "$txtDoc"
        echo $txtDoc
      fi
      if [ $? -eq 0 -a -e $txtDoc ]; then
        # First, extract all the information you need about this bill.
        # name TEXT <-- grep out the collecion code, its trailing hyphen, congress, and the billVersion

        _type=$(jq '.billType' $pkgDoc | tr -d '"')
        _version=$(jq '.billVersion' $pkgDoc | tr -d '"')
        _collectionCode=$(jq '.collectionCode' $pkgDoc | tr -d '"')
        _billNumber=$(jq '.billNumber' $pkgDoc | tr -d '"')
        desc=$(jq '.shortTitle[0].title' $pkgDoc | tr -d '"')
        if [ "$desc" = "null" ]; then
          desc=$(jq '.title' $pkgDoc | tr -d '"')
        fi
        nUpdates=0 #TODO
        nPages=$(jq '.pages' $pkgDoc | tr -d '"')
        stage=$(jq '.billVersion' $pkgDoc | tr -d '"')
        createdTm=$(jq '.dateIssued' $pkgDoc | date +%s | tr -d '"')
        lastUpdatedTm=$(jq '.lastModified' $pkgDoc | date +%s | tr -d '"')
        CONGRESS=$(jq  '.congress' $pkgDoc | tr -d '"')
        name=$CONGRESS$_type$_billNumber  # CONGRESS number isn't technically part of "bill slug", but it'll keep it unique across congresses.
        filepath="$REPO/db/$CONGRESS/$name"

        if [ ! -d $filepath ]; then
          echo "creating filepath $filepath"
          mkdir -p $filepath
          if [ $? -ne 0 ]; then
            echo "error making directory $filepath. Exitting..."
            exit 1
          fi
        fi

        execStr="
        sqlite3 '$DB' 'INSERT INTO bill (
          name,
          desc,
          nUpdates,
          nPages,
          stageId,
          filepath,
          createdTm,
          lastUpdatedTm)
        VALUES (
          \"$name\",
          \"$desc\",
          $nUpdates,
          $nPages,
          (select id from stage where lower(symbol) = lower(\"$stage\")),
          \"$filepath\",
          $createdTm,
          $lastUpdatedTm
        );'"
        echo $execStr  # good for debugging
        eval $execStr
      fi
    fi
    ((counter++))
  done
done
